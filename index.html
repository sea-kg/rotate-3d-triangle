
<table>
    <tr>
        <td style="vertical-align: top;">
            <canvas id="canvas" width=950px height=950px></canvas>
        </td>
        <td style="vertical-align: top;">
            <pre id="log"></pre>
        </td>

    </tr>

<script>

const el = document.getElementById('log');

function loginfo(s){
    el.innerHTML += s + "\n";
    console.log(s);
}

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

var max_size = 300;

var triangle1 = {
    p1: {x: 20, y: 60, z: 40},
    p2: {x: 20, y: 60, z: 40},
    p3: {x: 20, y: 60, z: 40},
};

var triangle2 = {
    p1: {x: 20, y: 60, z: 40},
    p2: {x: 20, y: 60, z: 40},
    p3: {x: 20, y: 60, z: 40},
};

function rand_coord() {
    return Math.floor(Math.random() * (max_size - 75) - (max_size - 75)/2); 
}

triangle1.p1.x = rand_coord();
triangle1.p1.y = rand_coord();
triangle1.p1.z = rand_coord();

triangle1.p2.x = rand_coord();
triangle1.p2.y = rand_coord();
triangle1.p2.z = rand_coord();

triangle1.p3.x = rand_coord();
triangle1.p3.y = rand_coord();
triangle1.p3.z = rand_coord();

triangle2.p1.x = triangle1.p1.x;
triangle2.p1.y = triangle1.p1.y;
triangle2.p1.z = triangle1.p1.z;

triangle2.p2.x = triangle1.p2.x;
triangle2.p2.y = triangle1.p2.y;
triangle2.p2.z = triangle1.p2.z;

triangle2.p3.x = triangle1.p3.x;
triangle2.p3.y = triangle1.p3.y;
triangle2.p3.z = triangle1.p3.z;

function vec_length(v0, v1) {
    var dx = v1.x - v0.x;
    var dy = v1.y - v0.y;
    var dz = v1.z - v0.z;

    return Math.sqrt(dx * dx + dy * dy + dz * dz);
}


// По оси X
// x'=x;
// y':=y*cos(L)+z*sin(L);
// z':=-y*sin(L)+z*cos(L);
// 
// По оси Y
// x'=x*cos(L)+z*sin(L);
// y'=y;
// z'=-x*sin(L)+z*cos(L);

// По оси Z
// x'=x*cos(L)-y*sin(L);
// y'=-x*sin(L)+y*cos(L);
// z'=z;

function radToDeg (rad) {
	return (rad * 180) / Math.PI;
}

function angel(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    _len = Math.sqrt(dx * dx + dy * dy);
    var ret = Math.asin(dx / _len);
    if (dy < 0) {
        ret = -1 * ret;
    } else {
        ret = ret;
    }
    return ret
}

// worked
function rotate_vec(vec0, vec1) {
    var ret = {};
    ret.x = vec0.x;
    ret.y = vec0.y;
    ret.z = vec0.z;
    var dx = vec1.x - vec0.x;
    var dy = vec1.y - vec0.y;
    var dz = vec1.z - vec0.z;

    _lenxz = Math.sqrt(dx * dx + dz * dz);
    _lenyz = Math.sqrt(dy * dy + dz * dz);

    var angelXZ = angel(dx, dz);
    loginfo("angelXZ (before) = " + angelXZ + ", deg=" + radToDeg(angelXZ));
   
    var angelYZ = Math.asin(dz / _lenyz);
    console.log("angelYZ = ", angelYZ)
    if (dz > 0) {
        // angelYZ = Math.PI + angelYZ
    }

    // help here:
    // https://stackoverflow.com/questions/14607640/rotating-a-vector-in-3d-space

    var rotxz = angelXZ;
    if (dz < 0) {
        rotxz = rotxz;
    } else {
        rotxz = -1 * rotxz;
    }

    // z axis
    // |cos θ   −sin θ   0| |x|   |x cos θ − y sin θ|   |x'|
    // |sin θ    cos θ   0| |y| = |x sin θ + y cos θ| = |y'|
    // |  0       0      1| |z|   |        z        |   |z'|
    // angelXZ = Math.PI; // angelYZ; // -1.0 * angelXZ;
    // ret.x += dx * Math.cos(-1 * angelXZ) - dy * Math.sin(-1 * angelXZ);
    // ret.y += dx * Math.sin(-1 * angelXZ) + dy * Math.cos(-1 * angelXZ);
    // ret.z += dz;
    
    // y axis
    // | cos θ    0   sin θ| |x|   | x cos θ + z sin θ|   |x'|
    // |   0      1       0| |y| = |         y        | = |y'|
    // |−sin θ    0   cos θ| |z|   |−x sin θ + z cos θ|   |z'|
    ret.x += dx * Math.cos(rotxz) + dz * Math.sin(rotxz);
    ret.y += dy;
    ret.z += -1.0 * dx * Math.sin(rotxz) + dz * Math.cos(rotxz);

    // x axis
    // |1     0           0| |x|   |        x        |   |x'|
    // |0   cos θ    −sin θ| |y| = |y cos θ − z sin θ| = |y'|
    // |0   sin θ     cos θ| |z|   |y sin θ + z cos θ|   |z'|
    // ret.x += dx;
    // ret.y += dy * Math.cos(rotxz) - dz * Math.sin(rotxz);
    // ret.z += dy * Math.sin(rotxz) + dz * Math.cos(rotxz);

    // result.y += (double)(y*cos(rotx) - z*sin(rotx));
    // result.z += (double)(y*sin(rotx) + z*cos(rotx));

    var dx = ret.x - vec0.x;
    var dy = ret.y - vec0.y;
    var dz = ret.z - vec0.z;
    angelXZ0 = angel(dx, dz);
    loginfo("angelXZ (after) = " + angelXZ0 + ", deg=" + radToDeg(angelXZ0));
    var sum = angelXZ0 + angelXZ;
    loginfo("angelXZ (sum) = " + sum + ", deg=" + radToDeg(sum));
    

    // ret.x = vec0.x
    //     + (dx * Math.sin(angelXZ) + dz * Math.cos(angelXZ))
    //     + (dy * Math.cos(angelYZ) - dz * Math.sin(angelYZ));
    // // ret.y = vec1.y; // * Math.sin(Math.PI/2 - angelYZ) - vec1.z * Math.cos(Math.PI/2 - angelYZ);
    // ret.y = vec0.y
    //     + (dx * Math.sin(angelXZ) + dz * Math.cos(angelXZ))
    //     + (dy * Math.cos(angelYZ) - dz * Math.sin(angelYZ))
    // ;
    // ret.z = 0;
    return ret
}

function rotate_z_azis(p1, p2, rot) {
    ret = {};

    ret.x = p1.x;
    ret.y = p1.y;
    ret.z = p1.z;
    var dx21 = p2.x - p1.x;
    var dy21 = p2.y - p1.y;
    var dz21 = p2.z - p1.z;

    // help here:
    // https://stackoverflow.com/questions/14607640/rotating-a-vector-in-3d-space
    
    // z axis
    // |cos θ   −sin θ   0| |x|   |x cos θ − y sin θ|   |x'|
    // |sin θ    cos θ   0| |y| = |x sin θ + y cos θ| = |y'|
    // |  0       0      1| |z|   |        z        |   |z'|

    ret.x += dx21 * Math.cos(rot) - dy21 * Math.sin(rot);
    ret.y += dx21 * Math.sin(rot) + dy21 * Math.cos(rot);
    ret.z += dz21;
    return ret;
}

function rotate_y_azis(p1, p2, rot) {
    ret = {};

    ret.x = p1.x;
    ret.y = p1.y;
    ret.z = p1.z;
    var dx21 = p2.x - p1.x;
    var dy21 = p2.y - p1.y;
    var dz21 = p2.z - p1.z;

    // help here:
    // https://stackoverflow.com/questions/14607640/rotating-a-vector-in-3d-space
    
    // y axis
    // | cos θ    0   sin θ| |x|   | x cos θ + z sin θ|   |x'|
    // |   0      1       0| |y| = |         y        | = |y'|
    // |−sin θ    0   cos θ| |z|   |−x sin θ + z cos θ|   |z'|

    ret.x += dx21 * Math.cos(rot) + dz21 * Math.sin(rot);
    ret.y += dy21;
    ret.z += -1.0 * dx21 * Math.sin(rot) + dz21 * Math.cos(rot);
    return ret;
}

function rotate_x_azis(p1, p2, rot) {
    ret = {};

    ret.x = p1.x;
    ret.y = p1.y;
    ret.z = p1.z;
    var dx21 = p2.x - p1.x;
    var dy21 = p2.y - p1.y;
    var dz21 = p2.z - p1.z;

    // help here:
    // https://stackoverflow.com/questions/14607640/rotating-a-vector-in-3d-space
    
    // x axis
    // |1     0           0| |x|   |        x        |   |x'|
    // |0   cos θ    −sin θ| |y| = |y cos θ − z sin θ| = |y'|
    // |0   sin θ     cos θ| |z|   |y sin θ + z cos θ|   |z'|

    ret.x += dx21;
    ret.y += dy21 * Math.cos(rot) - dz21 * Math.sin(rot);
    ret.z += dy21 * Math.sin(rot) + dz21 * Math.cos(rot);
    return ret;
}

function rotate_tr_xy(tr1) {
    // help here:
    // https://stackoverflow.com/questions/14607640/rotating-a-vector-in-3d-space

    var ret = {p1:{},p2:{},p3:{}};
    ret.p1.x = tr1.p1.x;
    ret.p1.y = tr1.p1.y;
    ret.p1.z = tr1.p1.z;

    ret.p2.x = tr1.p1.x;
    ret.p2.y = tr1.p1.y;
    ret.p2.z = tr1.p1.z;

    ret.p3.x = tr1.p1.x;
    ret.p3.y = tr1.p1.y;
    ret.p3.z = tr1.p1.z;

    var dx21 = tr1.p2.x - tr1.p1.x;
    var dy21 = tr1.p2.y - tr1.p1.y;
    var dz21 = tr1.p2.z - tr1.p1.z;

    var dx31 = tr1.p3.x - tr1.p1.x;
    var dy31 = tr1.p3.y - tr1.p1.y;
    var dz31 = tr1.p3.z - tr1.p1.z;

    var rotxz21 = angel(
        tr1.p1.x, tr1.p1.y,
        tr1.p2.x, tr1.p2.y
    );

    ret.p2 = rotate_z_azis(tr1.p1, tr1.p2, rotxz21);
    ret.p3 = rotate_z_azis(tr1.p1, tr1.p3, rotxz21);

    return ret
}

function rotate_tr_yz(tr1) {
    // help here:
    // https://stackoverflow.com/questions/14607640/rotating-a-vector-in-3d-space

    var ret = {p1:{},p2:{},p3:{}};
    ret.p1.x = tr1.p1.x;
    ret.p1.y = tr1.p1.y;
    ret.p1.z = tr1.p1.z;

    ret.p2.x = tr1.p1.x;
    ret.p2.y = tr1.p1.y;
    ret.p2.z = tr1.p1.z;

    ret.p3.x = tr1.p1.x;
    ret.p3.y = tr1.p1.y;
    ret.p3.z = tr1.p1.z;

    var dx21 = tr1.p2.x - tr1.p1.x;
    var dy21 = tr1.p2.y - tr1.p1.y;
    var dz21 = tr1.p2.z - tr1.p1.z;

    var dx31 = tr1.p3.x - tr1.p1.x;
    var dy31 = tr1.p3.y - tr1.p1.y;
    var dz31 = tr1.p3.z - tr1.p1.z;


    var rotyz = angel(
        tr1.p1.y, tr1.p1.z,
        tr1.p2.y, tr1.p2.z
    );

    ret.p2 = rotate_x_azis(tr1.p1, tr1.p2, rotyz);
    ret.p3 = rotate_x_azis(tr1.p1, tr1.p3, rotyz);

    return ret
}

// rotate_vec

// var angelXZ = Math.asin(vec1.x / vec2_length(vec1.x,vec1.z));
// console.log("angelXZ = ", angelXZ)

// if (vec1.z < 0) {
//     angelXZ = Math.PI - angelXZ
// } else {
//     // angelXZ = Math.PI/2 - angelXZ
// }

// var angelYZ = Math.acos(vec1.y / vec2_length(vec1.y,vec1.z));
// console.log("angelYZ = ", angelYZ)

function compare(name, vec00, vec01, vec10, vec11) {
    vec0_len = vec_length(vec00, vec01);
    vec1_len = vec_length(vec10, vec11);

    loginfo(name + " vec_len_before = " + vec0_len);
    loginfo(name + " vec_len_after = " + vec1_len);

    vec0_len = Math.floor(vec0_len).toFixed(4);
    vec1_len = Math.floor(vec1_len).toFixed(4);
    
    // console.log("vec0", vec0_len);
    // console.log("vec1", vec1_len);
    loginfo(name + " compare = " + (vec0_len == vec1_len));
    return vec0_len == vec1_len;
}


// vec2.z = 0
// vec2.x = vec1.x * Math.sin(angelXZ) + vec1.z * Math.cos(angelXZ);
// vec2.y = vec1.y; // * Math.sin(Math.PI/2 - angelYZ) - vec1.z * Math.cos(Math.PI/2 - angelYZ);

vec000 = {x: 0.0, y: 0.0, z: 0.0}
console.log(triangle1);

// triangle1.p1 = vec000
// triangle1.p2 = {x: 38.0, y: -13.0, z: 27.0}
// triangle1.p2 = {x: 0.0, y: -13.0, z: 27.0}
// triangle2.p1 = vec000
triangle2 = triangle1;
triangle2 = rotate_tr_xy(triangle2);
// triangle2 = rotate_tr_yz(triangle1)


// triangle2.p2 = rotate_vec(triangle1.p1, triangle1.p2)
// triangle2.p3 = rotate_vec(triangle1.p1, triangle1.p3)

// console.log(vec_length(triangle1.p1, triangle1.p2));
// console.log(vec_length(triangle2.p1, triangle2.p2));
// compare(
//     triangle1.p1, triangle1.p2,
//     triangle2.p1, triangle2.p2
// )

// triangle2.p1 = rotate_vec(triangle1.p3, triangle1.p1)
// triangle2.p2 = rotate_vec(triangle1.p1, triangle1.p2)
// triangle2.p3 = rotate_vec(triangle1.p1, triangle1.p3)

compare(
    "p1-p2",
    triangle2.p1, triangle2.p2,
    triangle1.p1, triangle1.p2
)
compare(
    "p2-p3",
    triangle2.p2, triangle2.p3,
    triangle1.p2, triangle1.p3
)
compare(
    "p3-p1",
    triangle2.p3, triangle2.p1,
    triangle1.p3, triangle1.p1
)

// triangle2.p1 = rotate_vec(triangle2.p1, triangle2.p2)
// triangle2.p3 = rotate_vec(triangle2.p2, triangle2.p3)
// triangle2.p1 = rotate_vec(triangle2.p3, triangle2.p1)

// // draw_line("x", "y",   0, 200, vec2.x, vec2.y);
// // draw_line("x", "z", 200, 200, vec2.x, vec2.z);
// // draw_line("y", "z", 400, 200, vec2.y, vec2.z);

// console.log("vec2", vec_length(vec2));

// vec1_len = Math.floor(vec_length(vec1)).toFixed(4)
// vec2_len = Math.floor(vec_length(vec2)).toFixed(4)

// console.log("compare", vec1_len == vec2_len);

// drawing

function draw_net(namex, namey, px, py) {
    px = px * max_size;
    
    ctx.lineWidth = 1;
    // coordinates 
    ctx.beginPath();
    ctx.moveTo(px + 10, py + max_size/2);
    ctx.lineTo(px + max_size - 20, py + max_size/2);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(px + max_size/2, py + 10);
    ctx.lineTo(px + max_size/2, py + max_size - 20);
    ctx.stroke();

    ctx.fillText(namey, px + max_size/2 + 5, py + 10);
    ctx.fillText(namex, px + max_size - 20, py + max_size/2 - 5);
}

function draw_line(name0, px, py, x0, y0, x1, y1) {
    px = px * max_size;

    // vector
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(px + max_size/2 + x0, py + max_size/2 - y0);
    ctx.lineTo(px + max_size/2 + x1, py + max_size/2 - y1);
    ctx.stroke();
    dy0 = 10;
    dy1 = 10;
    if (y0 > y1) {
        dy0 = -10;
        dy1 = 10;
    } else {
        dy0 = 10;
        dy1 = -10;
    }
    ctx.fillText(name0 + " (" + x0.toFixed(2) + ", " + y0.toFixed(2) + ")", px + max_size/2 + x0 + 5, py + max_size/2 - y0 + dy0);
    // ctx.fillText("b (" + x1.toFixed(2) + ", " + y1.toFixed(2) + ")", px + max_size/2 + x1 + 5, py + max_size/2 - y1 + dy1);
}


function draw_triangle(trgl, y) {
    y = y * max_size;
    draw_net("x", "y", 0, y);
    draw_line("p1xy",  0, y, trgl.p1.x, trgl.p1.y, trgl.p2.x, trgl.p2.y);
    draw_line("p2xy",  0, y, trgl.p2.x, trgl.p2.y, trgl.p3.x, trgl.p3.y);
    draw_line("p3xy",  0, y, trgl.p3.x, trgl.p3.y, trgl.p1.x, trgl.p1.y);

    draw_net("x", "z", 1, y);
    draw_line("p1xz", 1, y, trgl.p1.x, trgl.p1.z, trgl.p2.x, trgl.p2.z);
    draw_line("p2xz", 1, y, trgl.p2.x, trgl.p2.z, trgl.p3.x, trgl.p3.z);
    draw_line("p3xz", 1, y, trgl.p3.x, trgl.p3.z, trgl.p1.x, trgl.p1.z);

    draw_net("y", "z", 2, y);
    draw_line("p1yz", 2, y, trgl.p1.y, trgl.p1.z, trgl.p2.y, trgl.p2.z);
    draw_line("p2yz", 2, y, trgl.p2.y, trgl.p2.z, trgl.p3.y, trgl.p3.z);
    draw_line("p3yz", 2, y, trgl.p3.y, trgl.p3.z, trgl.p1.y, trgl.p1.z);   
}

function redraw() {
    console.log("redraw");
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, 1024, 1024);
    ctx.fillStyle = "black";
    draw_triangle(triangle1, 0);
    draw_triangle(triangle2, 1);
};

redraw();

setInterval(redraw, 1000);

</script>